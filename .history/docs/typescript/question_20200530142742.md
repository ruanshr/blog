
# Typescript常见问题

## 1、never 和 void 的区别

void表示没有任何类型（可以被赋值为null和undefined）

never表示一个不包含值得类型，即表示永远不存在的值。

拥有void返回值类型的喊声能正常运行，拥有never返回值类型的函数无法正常返回，无法终止，或会抛出异常。

## 2、元组越界问题
```ts
let a: [string, number] = ['aaa',5]
// 数组只能添加 string, number类型的值或者 null，undefined
a.push(6)  // 添加时不会报错,
console.log(a[2]) // 引用越界的元素时会报错

```

## 3 枚举成员的特点

是只读属性，无法修改

枚举成员值默认从0开始递增，可以自定义设置初始值。

```ts
enum Gender {
    BOY = 1,
    GIRL
}

console.log(Gender.BOY)  // 1
console.log(Gender)  // { '1': 'BOY', '2': 'GIRL', BOY: 1, GIRL: 2 }


```

枚举成员值
可以没有初始值
可以是一个队常亮成员的引用
可以是一个常量表达式
可以是一个非常量表达式

```ts
emum Car{
    // const member 常量成员;在编译阶段被计算出结果
    a,  // 没有初始值
    b = Char.a // 对常量成员的引用
    c = 1 + 2  // 常量表达式
    d = Math.random()  // 非常量表达式
    e = '123'.length,  
    // 紧跟在计算成员后面的枚举成员必须有初始值
    f = 6,
    g
}

```

## 4 常量枚举与普通枚举的区别

常量枚举会在编译阶段被删除
枚举成员只能是常量成员

```ts
const enum Colors {
    Red,
    Yellow,
    Blue
}

// 常量枚举会在编译阶段被删除
let myColors = [Colors.Red, Colors.Yellow, Colors.Blue]
```

编译成JS
```js
"use strict"
var myColors = [0 /" Red "/, 1 /* Yellow */, 2 /* Blue */]
```

常量枚举不能包含计算成员，如果包含了计算成员，则会在编译阶段报错

```ts
// 报错
const enum Colors { Red, Yellow, Blue = "blue".length }
console.log(Colors.Red)
```

## 枚举的使用场景

以下代码存在的问题：

可读性差,很难记住数字的含义
可维护性差,硬编码，后续修改的话牵一发动全身
```js
function initByRole(role) {
    if (role === 1 || role == 2) {
        console.log("1,2")
    } else if (role == 3 || role == 4) {
        console.log('3,4')
    } else if (role === 5) {
        console.log('5')
    } else {
        console.log('')
    }
}
```

使用枚举后

```ts
num Role {
  Reporter,
  Developer,
  Maintainer,
  Owner,
  Guest
}

function init(role: number) {
  switch (role) {
    case Role.Reporter:
      console.log("Reporter:1");
      break;
    case Role.Developer:
      console.log("Developer:2");
      break;
    case Role.Maintainer:
      console.log("Maintainer:3");
      break;
    case Role.Owner:
      console.log("Owner:4");
      break;
    default:
      console.log("Guest:5");
      break;
  }
}

init(Role.Developer);
```

## 6、什么是可索引类型接口

一般用來约束数组和对象

```ts
// 数字索引-约束数组
// index是随便取得名字，可以任意取名
// 只要 index得类型是number，那么值得类型必须是string
interface StringArray {
    [index: number]: string
}
let arr:StringArray = [ 'a', 'b' ]
console.log(arr)

// 字符串索引-约束对象
interface StringObject {
    [index: string]: string
}

let obj: StringObject = { name : 't'}
```

## 7、什么是函数类型接口

对方法传入的参数和返回值进行约束

```ts
// 注意区分

// 普通的接口
interface discount{
    getNum:(price: number) => number
}

// 函数类型接口
interface discount2{
    (price: numbuer): number
}

let cost:discount2 = function(price: number): number {
    return price *.7
}
// 也可以使用类型别名
type Add = (x: number, y: number) => number
let add:Add = (a: number, b: number): number => a + b
```