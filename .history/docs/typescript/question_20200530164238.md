
# Typescript常见问题

## 1、never 和 void 的区别

void表示没有任何类型（可以被赋值为null和undefined）

never表示一个不包含值得类型，即表示永远不存在的值。

拥有void返回值类型的喊声能正常运行，拥有never返回值类型的函数无法正常返回，无法终止，或会抛出异常。

## 2、元组越界问题
```ts
let a: [string, number] = ['aaa',5]
// 数组只能添加 string, number类型的值或者 null，undefined
a.push(6)  // 添加时不会报错,
console.log(a[2]) // 引用越界的元素时会报错

```

## 3 枚举成员的特点

是只读属性，无法修改

枚举成员值默认从0开始递增，可以自定义设置初始值。

```ts
enum Gender {
    BOY = 1,
    GIRL
}

console.log(Gender.BOY)  // 1
console.log(Gender)  // { '1': 'BOY', '2': 'GIRL', BOY: 1, GIRL: 2 }


```

枚举成员值
可以没有初始值
可以是一个队常亮成员的引用
可以是一个常量表达式
可以是一个非常量表达式

```ts
emum Car{
    // const member 常量成员;在编译阶段被计算出结果
    a,  // 没有初始值
    b = Char.a // 对常量成员的引用
    c = 1 + 2  // 常量表达式
    d = Math.random()  // 非常量表达式
    e = '123'.length,  
    // 紧跟在计算成员后面的枚举成员必须有初始值
    f = 6,
    g
}

```

## 4 常量枚举与普通枚举的区别

常量枚举会在编译阶段被删除
枚举成员只能是常量成员

```ts
const enum Colors {
    Red,
    Yellow,
    Blue
}

// 常量枚举会在编译阶段被删除
let myColors = [Colors.Red, Colors.Yellow, Colors.Blue]
```

编译成JS
```js
"use strict"
var myColors = [0 /" Red "/, 1 /* Yellow */, 2 /* Blue */]
```

常量枚举不能包含计算成员，如果包含了计算成员，则会在编译阶段报错

```ts
// 报错
const enum Colors { Red, Yellow, Blue = "blue".length }
console.log(Colors.Red)
```

## 枚举的使用场景

以下代码存在的问题：

可读性差,很难记住数字的含义
可维护性差,硬编码，后续修改的话牵一发动全身
```js
function initByRole(role) {
    if (role === 1 || role == 2) {
        console.log("1,2")
    } else if (role == 3 || role == 4) {
        console.log('3,4')
    } else if (role === 5) {
        console.log('5')
    } else {
        console.log('')
    }
}
```

使用枚举后

```ts
num Role {
  Reporter,
  Developer,
  Maintainer,
  Owner,
  Guest
}

function init(role: number) {
  switch (role) {
    case Role.Reporter:
      console.log("Reporter:1");
      break;
    case Role.Developer:
      console.log("Developer:2");
      break;
    case Role.Maintainer:
      console.log("Maintainer:3");
      break;
    case Role.Owner:
      console.log("Owner:4");
      break;
    default:
      console.log("Guest:5");
      break;
  }
}

init(Role.Developer);
```

## 6、什么是可索引类型接口

一般用來约束数组和对象

```ts
// 数字索引-约束数组
// index是随便取得名字，可以任意取名
// 只要 index得类型是number，那么值得类型必须是string
interface StringArray {
    [index: number]: string
}
let arr:StringArray = [ 'a', 'b' ]
console.log(arr)

// 字符串索引-约束对象
interface StringObject {
    [index: string]: string
}

let obj: StringObject = { name : 't'}
```

## 7、什么是函数类型接口

对方法传入的参数和返回值进行约束

```ts
// 注意区分

// 普通的接口
interface discount{
    getNum:(price: number) => number
}

// 函数类型接口
interface discount2{
    (price: numbuer): number
}

let cost:discount2 = function(price: number): number {
    return price *.7
}
// 也可以使用类型别名
type Add = (x: number, y: number) => number
let add:Add = (a: number, b: number): number => a + b
```


## 8、什么是类类型接口

如果接口用于一个类的话，那么接口会表示“行为的抽象”

对类的约束，让类去实现接口，类可以实现多个接口

接口只能约束类的公有成员，实例属性/方法，无法约束私有成员，构造函数，静态属性/方法

```ts
// 接口可以在面向对象编程中表示为行为的抽象
interface Speakable {
    name: string
    // 括号里的:用来约束函数的参数
    // 括号后的:用来约束函数的返回值
    speak(word: string): void

}


interface Speakable2 {
    age: numner
}

class Dog implements Speakable1, Speakable2 {
    name: string
    age: number = 1
    speak(words: string) {
        console.log(words)
    }
}

let dog = new Dog()
dog.speak('汪汪汪')

```

## 什么是混合类型接口

一个对象可以同时作为函数和对象使用

```ts

interface FnType {
    (getName: string): string
}

interface MixedType extends FnType {
    name: string
    age: number
}

```

```ts
interface Counter {
    (start: number): string
    interval: number
    reset(): void
}

function getCounter(): Counter {
    let counter = <Counter> function(start: number){}
    counter.interval = 123
    counter.reset = () => {}
    return counter
}

let c = getCounter()
c(10)
c.reset()
c.interval = 5.0

```

## 10、什么是函数重载

在java中的函数重载，指的是两个或者两个以上的同名函数，参数类型不同或者参数个数不同。函数重载的好处是：不需要为功能享受的函数起不同的名字。

在Typescript中，表现为给同一个函数提供多个函数类型定义，适用于接收不同的参数和返回不同结果的情况。

TS实现函数重载的时候，要求定义一系列的函数声明，在类型最宽泛的版本中实现重载（前面的是函数声明，目的是约束参数类型和个数，最后的函数实现是重载，表示要遵循前面的函数声明。一般在最后的函数实现时使用any类型）

函数重载在实际应用中使用的比较少，一般会用联合类型或泛型代替

函数重载的声明只用于类型检查阶段，在编译后悔被删除

TS编译在处理重载的时候，会查询函数声明列表，从上到下知道疲惫成功为止，所以要把最容易匹配的类型写到前面

```ts

function attr(val: string): string

function attr(val: number): number

function attr(val: any): any

attr('a')
attr('1')
```

上面的写法声明完函数后必须实现函数重载，也可以只声明函数

```ts

interface Cloner{
    clone(animal: Animal): Animal
}

interface Cloner{
    clone(animal: Sheep): Sheep
}

interface Cloner{
    clone(animal: Dog): Dog
    clone(animal: Cat): Cat
}

// 后面写的接口中的函数声明优先级高

interface Cloner {
    clone(animal: Dog): Dog
    clone(animal: Cat): Cat
    clone(animal: Sheep): Sheep
    clone(animal: Animal): Animal
}

```

## 11、什么是访问控制修饰符

```ts

class Father{
    str: string             // 默认是 public
    public name: string     // 在定义的类中，类的实例，子类，子类实例都可以访问
    protected age: number    // 只能在定义的类和子类中访问，不允许通过实例（定义的类的实例和子类实例）访问
    private money: number   // 只能在定义的类中访问，类的实例、子类、子类实例都不可以访问

    constructor(name: string, age: number, money: number){
        this.name = name
        this.age = age
        this.money = money
    }

    getName(): string{
        return this.name
    }
    setName(name: string){
        this.name = name
    }
    getAge(): number {
        return this.age
    }
}


const fa = new Father('张三',48,1000000)

console.log(fa.name) // 张三
console.log(fa.age)  // error
console.log(fa.money) // error
console.log(fa.getAge()) // 48

class Child extends Father{
    constructor(name: string, age: number, money: number){
      // 在super方法之前不能使用this,可以写其他
      super(name, age, money)  
      // super 方法之后可以使用this对象
    }

    desc() {
        console.log(`name: ${name}, age: ${age}, money: ${money} `)
    }
}


let child = new Child('李四', 18, 0)
console.log(child.name)   // 李四
console.log(child.age)    // error
console.log(child.money)  // error
```

## 2、重写（override） vs 重载（overload)

重写是指子类重写“继承”自父类中的方法。虽然TS与JAVA相似，但是TS中的继承本身上函数JS的“继承”机制-原型链继承机制

重载是指为同一个函数提供多个类型定义

```ts

class Animal {
    speak(word: string): string {
        return `animal speak : ${word}`
    }
}

class Cat extends Animal {
    speak(word: string): string {
        return `cat speak : ${word}`
    }
}


let cat = new Cat()
console.log(cat.speak('hello'))


/**=====================================**/

function double(val: number): number
function double(val: string): string
function double(val: any): any {
    if(typeof(val) === 'number'){
        return val * 2
    }
    return val + val
}

let r = double(3)
console.log(r)   // 6
let k = double('3')
console.log(k)  // '33'
```

## 13、继承 vs 多态

继承： 子类继承父类，子类除了拥有父类是的所有特性外，还有一些更具体的特性

多态： 由继承而产生了相关的不同的类，对同一个方法可以有不同的响应

```ts

class Animal {
    speak(word: string): string {
        return `animab speak : ${word}`
    }
}

class Cat extends Animal {
    speak(word: string): string {
        return `cat speak : ${word}`
    }
}

class Dog extends Animal {
    speak(word: string): string {
        return `Dog speak: ${word}`
    }
}

let cat = new Cat()
console.log(cat.speak('hello'))
let dog = new Dog()
console.log(dog.speak('hello'))

```


## 14、什么是泛型

泛型是指在定义函数、接口或者类的时候，不预先指定具体的类型，使用时再去指定类型的一种特性

可以吧泛型理解为代表类型的参数

```ts

function createArray<T>(length: number, value: T): Array<T> {
    let result: T[] = []
    for (let i = 0; i < len; i++ ) {
        result[i] = value
    }
    return result
}


```


## 15、什么是类型谓词

类型包含函数： 要自定义一个类型包含，只需要简单地为这个类型包含定义一个函数即可，这个函数的返回值是一个类型谓词

类型谓词的衣服为 parameterName is Type 这种形式，其中parameterName必须是当前函数前面里的一个参数名

```ts

interface Bird { 
    fly()
    layEggs()
}

interface Fish {
    swim()
    layEggs()
}

function getSmallPet(): Fish | Bird {
    return
}

let pet = getSmallPet()

pet.layEggs()

// 当使用联合类型时，如果不用类型短语，默认只会从中获取共有的部分
(pet as Fish).swin()

pet.swim()


// 使用类型谓词
function isFish(pet: Fish | Bird): pet is Fish {

    return (pet as Fish).swim !== undefined
}

if (isFish(pet)) {
    pet.swim()
} else {
    pet.fly()
}
```

## 16、可选链运算符的使用

可选链运算符是一种先检查属性是否存在，再尝试访问该属性的运算符，其符合为?.

如果运算符左侧的操作数?.计算为undefined或者null，则表达式求值为undefined，否则，正常出发模板属性访问，方法或者函数调用。

可选链运算符处于 stage3阶段，使用 @babel/plugin-proposal-optional-chaining 插件可以提前使用，TS 3.7版本正式支持使用，以前的版本会报错